{"ast":null,"code":"/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseConnection = require('../../connection');\nconst MongooseError = require('../../error/index');\nconst STATES = require('../../connectionState');\nconst mongodb = require('mongodb');\nconst pkg = require('../../../package.json');\nconst processConnectionOptions = require('../../helpers/processConnectionOptions');\nconst setTimeout = require('../../helpers/timers').setTimeout;\nconst utils = require('../../utils');\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n  // Tracks the last time (as unix timestamp) the connection received a\n  // serverHeartbeatSucceeded or serverHeartbeatFailed event from the underlying MongoClient.\n  // If we haven't received one in a while (like due to a frozen AWS Lambda container) then\n  // `readyState` is likely stale.\n  this._lastHeartbeatAt = null;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function (name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n  newConn.client = _this.client;\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this._queue.push({\n      fn: wireup\n    });\n  }\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn._lastHeartbeatAt = _this._lastHeartbeatAt;\n    newConn.onOpen();\n  }\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n  return newConn;\n};\n\n/**\n * Removes the database connection with the given name created with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n */\n\nNativeConnection.prototype.removeDb = function removeDb(name) {\n  const dbs = this.otherDbs.filter(db => db.name === name);\n  if (!dbs.length) {\n    throw new MongooseError(`No connections to database \"${name}\" found`);\n  }\n  for (const db of dbs) {\n    db._closeCalled = true;\n    db._destroyCalled = true;\n    db._readyState = STATES.disconnected;\n    db.$wasForceClosed = true;\n  }\n  delete this.relatedDbs[name];\n  this.otherDbs = this.otherDbs.filter(db => db.name !== name);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n  if (skipCloseClient) {\n    return this;\n  }\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n  return this;\n};\n\n/**\n * Implementation of `listDatabases()` for MongoDB driver\n *\n * @return Promise\n * @api public\n */\n\nNativeConnection.prototype.listDatabases = async function listDatabases() {\n  await this._waitForConnect();\n  return await this.db.admin().listDatabases();\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.createClient = async function createClient(uri, options) {\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' + `string, got \"${typeof uri}\". Make sure the first parameter to ` + '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n  if (this._destroyCalled) {\n    throw new MongooseError('Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' + 'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.');\n  }\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString !== uri) {\n      throw new MongooseError('Can\\'t call `openUri()` on an active connection with ' + 'different connection strings. Make sure you aren\\'t calling `mongoose.connect()` ' + 'multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections');\n    }\n  }\n  options = processConnectionOptions(uri, options);\n  if (options) {\n    const autoIndex = options.config && options.config.autoIndex != null ? options.config.autoIndex : options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n    if ('sanitizeFilter' in options) {\n      this.config.sanitizeFilter = options.sanitizeFilter;\n      delete options.sanitizeFilter;\n    }\n    if ('autoSearchIndex' in options) {\n      this.config.autoSearchIndex = options.autoSearchIndex;\n      delete options.autoSearchIndex;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.username = options.user;\n      options.auth.password = options.pass;\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n    if (options.bufferCommands != null) {\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n  } else {\n    options = {};\n  }\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n  if (!utils.hasUserDefinedProperty(options, 'driverInfo')) {\n    options.driverInfo = {\n      name: 'Mongoose',\n      version: pkg.version\n    };\n  }\n  this.readyState = STATES.connecting;\n  this._connectionString = uri;\n  let client;\n  try {\n    client = new mongodb.MongoClient(uri, options);\n  } catch (error) {\n    this.readyState = STATES.disconnected;\n    throw error;\n  }\n  this.client = client;\n  client.setMaxListeners(0);\n  await client.connect();\n  _setClient(this, client, options, dbName);\n  for (const db of this.otherDbs) {\n    _setClient(db, client, {}, db.name);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.setClient = function setClient(client) {\n  if (!(client instanceof mongodb.MongoClient)) {\n    throw new MongooseError('Must call `setClient()` with an instance of MongoClient');\n  }\n  if (this.readyState !== STATES.disconnected) {\n    throw new MongooseError('Cannot call `setClient()` on a connection that is already connected.');\n  }\n  if (client.topology == null) {\n    throw new MongooseError('Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.');\n  }\n  this._connectionString = client.s.url;\n  _setClient(this, client, {}, client.s.options.dbName);\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _setClient(conn, client, options, dbName) {\n  const db = dbName != null ? client.db(dbName) : client.db();\n  conn.db = db;\n  conn.client = client;\n  conn.host = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].host || void 0;\n  conn.port = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].port || void 0;\n  conn.name = dbName != null ? dbName : db.databaseName;\n  conn._closeCalled = client._closeCalled;\n  const _handleReconnect = () => {\n    // If we aren't disconnected, we assume this reconnect is due to a\n    // socket timeout. If there's no activity on a socket for\n    // `socketTimeoutMS`, the driver will attempt to reconnect and emit\n    // this event.\n    if (conn.readyState !== STATES.connected) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n      conn.onOpen();\n    }\n  };\n  const type = client && client.topology && client.topology.description && client.topology.description.type || '';\n  if (type === 'Single') {\n    client.on('serverDescriptionChanged', ev => {\n      const newDescription = ev.newDescription;\n      if (newDescription.type === 'Unknown') {\n        conn.readyState = STATES.disconnected;\n      } else {\n        _handleReconnect();\n      }\n    });\n  } else if (type.startsWith('ReplicaSet')) {\n    client.on('topologyDescriptionChanged', ev => {\n      // Emit disconnected if we've lost connectivity to the primary\n      const description = ev.newDescription;\n      if (conn.readyState === STATES.connected && description.type !== 'ReplicaSetWithPrimary') {\n        // Implicitly emits 'disconnected'\n        conn.readyState = STATES.disconnected;\n      } else if (conn.readyState === STATES.disconnected && description.type === 'ReplicaSetWithPrimary') {\n        _handleReconnect();\n      }\n    });\n  }\n  client.on('serverHeartbeatSucceeded', () => {\n    conn._lastHeartbeatAt = Date.now();\n  });\n  if (options.monitorCommands) {\n    client.on('commandStarted', data => conn.emit('commandStarted', data));\n    client.on('commandFailed', data => conn.emit('commandFailed', data));\n    client.on('commandSucceeded', data => conn.emit('commandSucceeded', data));\n  }\n  conn.onOpen();\n  if (client.topology?.s?.state === 'connected') {\n    conn._lastHeartbeatAt = Date.now();\n  }\n  for (const i in conn.collections) {\n    if (utils.object.hasOwnProperty(conn.collections, i)) {\n      conn.collections[i].onOpen();\n    }\n  }\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;","map":{"version":3,"names":["MongooseConnection","require","MongooseError","STATES","mongodb","pkg","processConnectionOptions","setTimeout","utils","NativeConnection","apply","arguments","_listening","_lastHeartbeatAt","Object","setPrototypeOf","prototype","useDb","name","options","useCache","relatedDbs","newConn","constructor","base","collections","models","replica","config","assign","_readyState","_closeCalled","_hasOpened","_parent","host","port","user","pass","_this","client","db","connected","wireup","_queue","push","fn","_opts","hasOwnProperty","noListener","onOpen","otherDbs","removeDb","dbs","filter","length","_destroyCalled","disconnected","$wasForceClosed","doClose","force","skipCloseClient","close","Promise","resolve","listDatabases","_waitForConnect","admin","createClient","uri","readyState","connecting","_connectionString","autoIndex","autoCreate","sanitizeFilter","autoSearchIndex","auth","username","password","bufferCommands","_connectionOptions","dbName","$dbName","hasUserDefinedProperty","driverInfo","version","MongoClient","error","setMaxListeners","connect","_setClient","setClient","topology","s","url","model","values","init","catch","$modelInitNoop","conn","hosts","databaseName","_handleReconnect","emit","type","description","on","ev","newDescription","startsWith","Date","now","monitorCommands","data","state","i","object","module","exports"],"sources":["C:/Users/wliu6/OneDrive/Desktop/Web Development/we-detox/Anon-Connect/anon-connect/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseConnection = require('../../connection');\nconst MongooseError = require('../../error/index');\nconst STATES = require('../../connectionState');\nconst mongodb = require('mongodb');\nconst pkg = require('../../../package.json');\nconst processConnectionOptions = require('../../helpers/processConnectionOptions');\nconst setTimeout = require('../../helpers/timers').setTimeout;\nconst utils = require('../../utils');\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n  // Tracks the last time (as unix timestamp) the connection received a\n  // serverHeartbeatSucceeded or serverHeartbeatFailed event from the underlying MongoClient.\n  // If we haven't received one in a while (like due to a frozen AWS Lambda container) then\n  // `readyState` is likely stale.\n  this._lastHeartbeatAt = null;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this._queue.push({ fn: wireup });\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn._lastHeartbeatAt = _this._lastHeartbeatAt;\n    newConn.onOpen();\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n\n/**\n * Removes the database connection with the given name created with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n */\n\nNativeConnection.prototype.removeDb = function removeDb(name) {\n  const dbs = this.otherDbs.filter(db => db.name === name);\n  if (!dbs.length) {\n    throw new MongooseError(`No connections to database \"${name}\" found`);\n  }\n\n  for (const db of dbs) {\n    db._closeCalled = true;\n    db._destroyCalled = true;\n    db._readyState = STATES.disconnected;\n    db.$wasForceClosed = true;\n  }\n  delete this.relatedDbs[name];\n  this.otherDbs = this.otherDbs.filter(db => db.name !== name);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n\n  if (skipCloseClient) {\n    return this;\n  }\n\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n\n  return this;\n};\n\n/**\n * Implementation of `listDatabases()` for MongoDB driver\n *\n * @return Promise\n * @api public\n */\n\nNativeConnection.prototype.listDatabases = async function listDatabases() {\n  await this._waitForConnect();\n\n  return await this.db.admin().listDatabases();\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.createClient = async function createClient(uri, options) {\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' +\n      `string, got \"${typeof uri}\". Make sure the first parameter to ` +\n      '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n\n  if (this._destroyCalled) {\n    throw new MongooseError(\n      'Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' +\n      'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.'\n    );\n  }\n\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString !== uri) {\n      throw new MongooseError('Can\\'t call `openUri()` on an active connection with ' +\n        'different connection strings. Make sure you aren\\'t calling `mongoose.connect()` ' +\n        'multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections');\n    }\n  }\n\n  options = processConnectionOptions(uri, options);\n\n  if (options) {\n\n    const autoIndex = options.config && options.config.autoIndex != null ?\n      options.config.autoIndex :\n      options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n\n    if ('sanitizeFilter' in options) {\n      this.config.sanitizeFilter = options.sanitizeFilter;\n      delete options.sanitizeFilter;\n    }\n\n    if ('autoSearchIndex' in options) {\n      this.config.autoSearchIndex = options.autoSearchIndex;\n      delete options.autoSearchIndex;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.username = options.user;\n      options.auth.password = options.pass;\n\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n\n    if (options.bufferCommands != null) {\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n  } else {\n    options = {};\n  }\n\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n\n  if (!utils.hasUserDefinedProperty(options, 'driverInfo')) {\n    options.driverInfo = {\n      name: 'Mongoose',\n      version: pkg.version\n    };\n  }\n\n  this.readyState = STATES.connecting;\n  this._connectionString = uri;\n\n  let client;\n  try {\n    client = new mongodb.MongoClient(uri, options);\n  } catch (error) {\n    this.readyState = STATES.disconnected;\n    throw error;\n  }\n  this.client = client;\n\n  client.setMaxListeners(0);\n  await client.connect();\n\n  _setClient(this, client, options, dbName);\n\n  for (const db of this.otherDbs) {\n    _setClient(db, client, {}, db.name);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.setClient = function setClient(client) {\n  if (!(client instanceof mongodb.MongoClient)) {\n    throw new MongooseError('Must call `setClient()` with an instance of MongoClient');\n  }\n  if (this.readyState !== STATES.disconnected) {\n    throw new MongooseError('Cannot call `setClient()` on a connection that is already connected.');\n  }\n  if (client.topology == null) {\n    throw new MongooseError('Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.');\n  }\n\n  this._connectionString = client.s.url;\n  _setClient(this, client, {}, client.s.options.dbName);\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _setClient(conn, client, options, dbName) {\n  const db = dbName != null ? client.db(dbName) : client.db();\n  conn.db = db;\n  conn.client = client;\n  conn.host = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].host || void 0;\n  conn.port = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].port || void 0;\n  conn.name = dbName != null ? dbName : db.databaseName;\n  conn._closeCalled = client._closeCalled;\n\n  const _handleReconnect = () => {\n    // If we aren't disconnected, we assume this reconnect is due to a\n    // socket timeout. If there's no activity on a socket for\n    // `socketTimeoutMS`, the driver will attempt to reconnect and emit\n    // this event.\n    if (conn.readyState !== STATES.connected) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n      conn.onOpen();\n    }\n  };\n\n  const type = client &&\n  client.topology &&\n  client.topology.description &&\n  client.topology.description.type || '';\n\n  if (type === 'Single') {\n    client.on('serverDescriptionChanged', ev => {\n      const newDescription = ev.newDescription;\n      if (newDescription.type === 'Unknown') {\n        conn.readyState = STATES.disconnected;\n      } else {\n        _handleReconnect();\n      }\n    });\n  } else if (type.startsWith('ReplicaSet')) {\n    client.on('topologyDescriptionChanged', ev => {\n      // Emit disconnected if we've lost connectivity to the primary\n      const description = ev.newDescription;\n      if (conn.readyState === STATES.connected && description.type !== 'ReplicaSetWithPrimary') {\n        // Implicitly emits 'disconnected'\n        conn.readyState = STATES.disconnected;\n      } else if (conn.readyState === STATES.disconnected && description.type === 'ReplicaSetWithPrimary') {\n        _handleReconnect();\n      }\n    });\n  }\n  client.on('serverHeartbeatSucceeded', () => {\n    conn._lastHeartbeatAt = Date.now();\n  });\n\n  if (options.monitorCommands) {\n    client.on('commandStarted', (data) => conn.emit('commandStarted', data));\n    client.on('commandFailed', (data) => conn.emit('commandFailed', data));\n    client.on('commandSucceeded', (data) => conn.emit('commandSucceeded', data));\n  }\n\n  conn.onOpen();\n  if (client.topology?.s?.state === 'connected') {\n    conn._lastHeartbeatAt = Date.now();\n  }\n\n  for (const i in conn.collections) {\n    if (utils.object.hasOwnProperty(conn.collections, i)) {\n      conn.collections[i].onOpen();\n    }\n  }\n}\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}