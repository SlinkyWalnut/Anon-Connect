{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/schemaArrayOptions');\nconst SchemaType = require('../schemaType');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst VirtualOptions = require('../options/virtualOptions');\nconst VirtualType = require('../virtualType');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst clone = require('../helpers/clone');\nconst getConstructorName = require('../helpers/getConstructorName');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\nlet MongooseArray;\nlet EmbeddedDoc;\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n  if (cast) {\n    let castOptions = {};\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n    this.casterConstructor = caster;\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n    if (typeof caster === 'function' && !caster.$isArraySubdocument && !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n    this.$embeddedSchemaType = this.caster;\n  }\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array');\n  let defaultArr;\n  let fn;\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n  if (!('defaultValue' in this) || this.defaultValue != null) {\n    const defaultFn = function () {\n      // Leave it up to `cast()` to convert the array\n      return fn ? defaultArr.call(this) : defaultArr != null ? [].concat(defaultArr) : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = {\n  castNonArrays: true\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\nSchemaArray.setters = [];\n\n/**\n * Attaches a getter for all Array instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaArray.get = SchemaType.get;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/*!\n * Virtuals defined on this array itself.\n */\n\nSchemaArray.prototype.virtuals = null;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ? this.constructor.checkRequired() : SchemaArray.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function () {\n  let arr = this;\n  while (true) {\n    const instance = arr && arr.caster && arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' + ', not ' + instance);\n    }\n    break;\n  }\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  return ret;\n};\nSchemaArray.prototype._applySetters = function (value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  let i;\n  let l;\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ? this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n    options = options || emptyOpts;\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    let path = options.path || this.path;\n    if (options.arrayPathIndex != null) {\n      path += '.' + options.arrayPathIndex;\n    }\n    value = MongooseArray(rawValue, path, doc, this);\n    rawValue = value.__array;\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n    return value;\n  }\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n    return value;\n  }\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function (...args) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' + 'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(...args);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\nSchemaArray.prototype._castForQuery = function (val, context) {\n  let Constructor = this.casterConstructor;\n  if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {\n    if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n  const proto = this.casterConstructor.prototype;\n  const protoCastForQuery = proto && proto.castForQuery;\n  const protoCast = proto && proto.cast;\n  const constructorCastForQuery = Constructor.castForQuery;\n  const caster = this.caster;\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function (v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      if (protoCastForQuery) {\n        v = protoCastForQuery.call(caster, null, v, context);\n        return v;\n      } else if (protoCast) {\n        v = protoCast.call(caster, v);\n        return v;\n      } else if (constructorCastForQuery) {\n        v = constructorCastForQuery.call(caster, null, v, context);\n        return v;\n      }\n      if (v != null) {\n        v = new Constructor(v);\n        return v;\n      }\n      return v;\n    });\n  } else if (protoCastForQuery) {\n    val = protoCastForQuery.call(caster, null, val, context);\n  } else if (protoCast) {\n    val = protoCast.call(caster, val);\n  } else if (constructorCastForQuery) {\n    val = constructorCastForQuery.call(caster, null, val, context);\n  } else if (val != null) {\n    val = new Constructor(val);\n  }\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function ($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\n\n/**\n * Add a virtual to this array. Specifically to this array, not the individual elements.\n *\n * @param {String} name\n * @param {Object} [options]\n * @api private\n */\n\nSchemaArray.prototype.virtual = function virtual(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    throw new MongooseError('Cannot set populate virtual as a property of an array');\n  }\n  const virtual = new VirtualType(options, name);\n  if (this.virtuals === null) {\n    this.virtuals = {};\n  }\n  this.virtuals[name] = virtual;\n  return virtual;\n};\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n  val = val.map(v => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return {\n        $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context)\n      };\n    }\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];\n  }, this);\n  return this.castForQuery(null, val, context);\n}\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n  return val;\n}\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val, context) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema ?? context.schema, obj, null, this && this.$$context));\n    }\n    return ret;\n  };\n}\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$not = handle.$regex = handle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"names":["$exists","require","$type","MongooseError","SchemaArrayOptions","SchemaType","CastError","Mixed","VirtualOptions","VirtualType","arrayDepth","cast","clone","getConstructorName","isOperator","util","utils","castToNumber","geospatial","getDiscriminatorByValue","MongooseArray","EmbeddedDoc","isNestedArraySymbol","Symbol","emptyOpts","Object","freeze","SchemaArray","key","options","schemaOptions","Embedded","typeKey","castOptions","isPOJO","ref","name","getFunctionName","Types","caster","hasOwnProperty","casterConstructor","$isArraySubdocument","$isSchemaMap","path","$embeddedSchemaType","$isMongooseArray","call","defaultArr","fn","defaultValue","defaultFn","concat","$runBeforeSetters","default","schemaName","castNonArrays","defaultOptions","set","setters","get","prototype","create","constructor","OptionsConstructor","_checkRequired","checkRequired","virtuals","value","doc","_isRef","enum","arr","instance","Error","enumArray","arguments","Array","isArray","isObject","object","vals","apply","applyGetters","scope","$__","$populated","ret","_applySetters","init","priorVal","depth","$isMongooseDocumentArray","length","valueDepth","min","max","containsNonArrayItem","i","prev","l","len","indexes","schema","indexedPaths","arrayPath","pathIndex","arrayGeojsonPath","endsWith","substring","lastIndexOf","rawValue","isMongooseArray","__array","arrayPathIndex","opts","_arrayParentPath","applySetters","e","kind","inspect","castNonArraysOption","markModified","_castForPopulate","$toObject","toObject","discriminator","args","assign","schematype","validators","slice","requiredValidator","undefined","_castForQuery","val","context","Constructor","discriminators","discriminatorKey","constructorByValue","proto","protoCastForQuery","castForQuery","protoCast","constructorCastForQuery","reverse","forEach","setter","map","v","$elemMatch","$conditional","handler","$conditionalHandlers","virtual","hasUserDefinedProperty","cast$all","$$context","o","cast$elemMatch","keys","numKeys","handle","$all","$options","String","$geoIntersects","cast$geoIntersects","$or","createLogicalQueryOperatorHandler","$and","$nor","op","logicalQueryOperatorHandler","TypeError","obj","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$lt","$lte","$not","$regex","$ne","$nin","$in","module","exports"],"sources":["C:/Users/wliu6/OneDrive/Desktop/Web Development/we-detox/Anon-Connect/anon-connect/node_modules/mongoose/lib/schema/array.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/schemaArrayOptions');\nconst SchemaType = require('../schemaType');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst VirtualOptions = require('../options/virtualOptions');\nconst VirtualType = require('../virtualType');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst clone = require('../helpers/clone');\nconst getConstructorName = require('../helpers/getConstructorName');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue != null) {\n    const defaultFn = function() {\n      // Leave it up to `cast()` to convert the array\n      return fn\n        ? defaultArr.call(this)\n        : defaultArr != null\n          ? [].concat(defaultArr)\n          : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\nSchemaArray.setters = [];\n\n/**\n * Attaches a getter for all Array instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaArray.get = SchemaType.get;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/*!\n * Virtuals defined on this array itself.\n */\n\nSchemaArray.prototype.virtuals = null;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = arr &&\n    arr.caster &&\n    arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    let path = options.path || this.path;\n    if (options.arrayPathIndex != null) {\n      path += '.' + options.arrayPathIndex;\n    }\n    value = MongooseArray(rawValue, path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function(...args) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(...args);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\nSchemaArray.prototype._castForQuery = function(val, context) {\n  let Constructor = this.casterConstructor;\n\n  if (val &&\n      Constructor.discriminators &&\n      Constructor.schema &&\n      Constructor.schema.options &&\n      Constructor.schema.options.discriminatorKey) {\n    if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  const proto = this.casterConstructor.prototype;\n  const protoCastForQuery = proto && proto.castForQuery;\n  const protoCast = proto && proto.cast;\n  const constructorCastForQuery = Constructor.castForQuery;\n  const caster = this.caster;\n\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function(v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      if (protoCastForQuery) {\n        v = protoCastForQuery.call(caster, null, v, context);\n        return v;\n      } else if (protoCast) {\n        v = protoCast.call(caster, v);\n        return v;\n      } else if (constructorCastForQuery) {\n        v = constructorCastForQuery.call(caster, null, v, context);\n        return v;\n      }\n      if (v != null) {\n        v = new Constructor(v);\n        return v;\n      }\n      return v;\n    });\n  } else if (protoCastForQuery) {\n    val = protoCastForQuery.call(caster, null, val, context);\n  } else if (protoCast) {\n    val = protoCast.call(caster, val);\n  } else if (constructorCastForQuery) {\n    val = constructorCastForQuery.call(caster, null, val, context);\n  } else if (val != null) {\n    val = new Constructor(val);\n  }\n\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\n\n/**\n * Add a virtual to this array. Specifically to this array, not the individual elements.\n *\n * @param {String} name\n * @param {Object} [options]\n * @api private\n */\n\nSchemaArray.prototype.virtual = function virtual(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    throw new MongooseError('Cannot set populate virtual as a property of an array');\n  }\n\n  const virtual = new VirtualType(options, name);\n  if (this.virtuals === null) {\n    this.virtuals = {};\n  }\n  this.virtuals[name] = virtual;\n  return virtual;\n};\n\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map((v) => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };\n    }\n\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];\n  }, this);\n\n  return this.castForQuery(null, val, context);\n}\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  return val;\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val, context) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema ?? context.schema, obj, null, this && this.$$context));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$not =\nhandle.$regex =\nhandle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}